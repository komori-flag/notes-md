# 解构赋值
## 一：数组的解构赋值
在 ES5 当中，为一个变量进行赋值，只能直接指定值。
```javascript
var a = 1,
    b = 2,
    c = 3;
```

在 ES6 当中`可以从数组中提取值`，分别对变量一一赋值。

这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。
```javascript
let [a, b, c] = [1, 2, 3];
```

如果解构不成功，变量的值就等于undefined
```javascript
let [foo] = []; // [undefined]
let [bar, foo] = [1]; // [1, undefined]
```

另一种情况是`不完全解构`，即等号左边的模式，<font color=skyblue>部分匹配等号右边的数组</font>。这种情况下，解构依然可以成功。
```javascript
let [x, y] = [1, 3, 6]; // x = 1、y = 3
let [a, [b], c] = [1, [3, 2], 6]; // a = 1、b = 3、c = 6
```

注：如果等号的右边不是数组，那么将会报错。
```javascript
let [foo] = 1;
let [foo] = false;
let [foo] = NaN;
let [foo] = undefined;
let [foo] = null;
let [foo] = {};
// 错误：类型必须具有返回迭代器的 [Symbol.iterator]() 方法。
```
---
关于解构赋值的<font color=red size=4>**默认值**</font>

解构赋值允许指定默认值。
```javascript
let [foo = true] = [];
foo // true
```

注：ES6 的解构赋值内部会使用严格相等运算符（===），执行时会判断一个位置是否有值（!=undefined）。只有当一个数组成员严格等于undefined，默认值才会生效。
```javascript
let [x = 1] = [undefined],
    [y = 1] = [null];
console.log(x); // x = 1
console.log(y); // y = null
```

如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。
```javascript
function f() {console.log("输出")};
let [x = f()] = [1];
console.log(x); // x = 1
```

默认值可以引用解构赋值的其他变量，但该变量必须已经声明。
```javascript
let [x = 1, y = x] = [], // x = 1、y = 1
    [a = b, b = 1] = []; // // ReferenceError: b is not defined
// 因为a用b做默认值时，b还没有声明。
```

---
## 二：对象的解构赋值
对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。

所有的键和它们的值，都会被<font color=skybiue size=3>浅拷贝</font>到新对象上面。
```javascript
let node = {
    type: "idten",
    name: "foore"
}

// 完全解构（全部拷贝）
let {type, name} = node;
console.log(type + " " + name);

// 不完全解构（部分拷贝）
let {type} = node;
console.log(type);
```

由于解构赋值要求等号右边是一个对象，所以如果等号右边是undefined或null，就会报错，因为它们无法转为对象。

```javascript
let { ...z } = null; // 运行时错误
let { ...z } = undefined; // 运行时错误
```

由于解构赋值的拷贝为`浅拷贝`，所以如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。
```javascript
let obj = {a: {b: 1}},
    {...x} = obj;
x.a.b = 10;
console.log(obj.a.b); // 10
```

扩展运算符的解构赋值，`不能复制继承自原型对象的属性`。
```javascript
let o1 = { a: 1 };
let o2 = { b: 2 };
o2.__proto__ = o1;
let { ...o3 } = o2;
o3 // { b: 2 }
o3.a // undefined
```