# 函数的扩展
## 一：函数参数的默认值
在 ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法，而变通方式用多了便会感到繁琐。
```javascript
function log(x, y) {
    // 为了避免这个问题，通常需要先判断一下参数y是否被赋值，如果没有，再等于默认值。
    if(typeof x === 'undefined') {
        x = "Hello";
    };
    if(typeof y === 'undefined') {
        y = "World";
    };
    // 对应的布尔值如为false，则该赋值不起作用。
    var x = x | "Hello",
        y = y | "World";
    console.log(x + y);
}

log(); // HelloWorld
log("hello"); // helloWorld
log("" ,"China"); // HelloChina
```

而 ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。
```javascript
function log(x, y = "World") {
  console.log(x, y);
}

log('Hello') // Hello World
log('Hello', 'China') // Hello China
log('Hello', '') // Hello
```
可以看到，ES6 的写法比 ES5 简洁许多，而且非常自然。

---
## 二：rest 参数
在传统 ES5 当中，对于未知传参数量（多余参数）我们需要使用 `arguments` 对象。
>注：arguments 是一个对应于传递给函数参数的`类数组对象`，它可以通过一个对象来获取所有参数，多用于对同个方法多处调用并且传递参数个数不一样时。
```javascript
function sayHi() {
    console.log("hello " + arguments[0] + "," + arguments[1] + "," + arguments[2]);
}
sayHi("sa", "shi", "su");
```

ES6 引入<font color=#00ffff>rest 参数[形式为：“...变量名（变量名可自拟）”]</font> ，用于获取函数的多余参数，这样就不需要使用 arguments 对象了。
```javascript
function sayHi(...values) {
    let sum = 0;
    for(let val of values) {
        sum += ("," + val);
    };
    return sum;
}
sayHi("sa", "shi", "su");
```
---
## 三：扩展运算符与剩余操作符
### **1.扩展运算符**
<font color=red>**扩展运算符**</font>可以将一个数组分割，并将各个项作为分离的参数传递给函数。

例：
```javascript
// 处理数组当中的最大值（ES5 apply方法）
const arr = [10,20,30,40,45,50];
console.log(Math.max.apply(null, arr)); // 50
// ES6 rest 参数方法
console.log(Math.max(...arr)); // 50，此处使用rest参数方法可以将数组中的值拆分成多个参数传递进函数当中。
```

这样可以使得将数组作为函数的参数传递进去更加的方便，同时也更加直观地看到函数是怎么处理传入的参数。

### **2.剩余运算符**
<font color=red>剩余参数（rest parameter）</font>允许长度不确定的实参表示为一个数组。

如果一个函数的最后一个形参是使用 rest 参数方法的，则在函数被调用时，该形参会成为一个数组，数组中的元素都是传递给该函数的多出来的实参的值。
```javascript
// 使用arguments方法
function fn_01(a) {
    let newArr = [];
    console.log(a); // 12
    for(let i = 1 ; i < arguments.length ; i++) {
        newArr.push(arguments[i]);
    };
    return newArr;
}
console.log(fn_01(12, 14, 16, 18, 20)); // [14,16,18,20]
// 使用rest参数方法
function fn_02(a, ...args) {
    console.log(a); // 12
    return args;
}
console.log(fn_02(12, 14, 16, 18, 20));// [14,16,18,20]
```

---
## 四：箭头函数
<font color=red size=3>箭头函数（()=>{}）</font>就是使用“=>”来代替“function”来定义一个函数的写法，等同于ES5当中的定义函数（function(){}）的写法。

```javascript
// ES5 函数定义
function fn_01() {};
// ES6 箭头函数定义
fn_01() => {};
```

如果箭头函数只有一个参数，可以<font color=skyblue>用一个参数名代表参数部分</font>。
```javascript
let f = val => {};
```

如果箭头函数不需要参数或需要多个参数，就<font color=skyblue>用一个圆括号代表参数部分</font>。
```javascript
let a = () => {};
// 等同于
let a = function () {};
```

如果箭头函数的代码块<font color=orange>只有一条语句且返回一个值</font>，<font color=skyblue>可以直接写参数名，等同于返回参数值</font>。
```javascript
let f = val => val; 
// 相当于
let f = function(val) {
    return val;
}
```
如果需要附加运算，可以使用圆括号将运算式括起来，表示此为表达式。
```javascript
let f = val => (val + 5); // // 相当于return val + 5;
```

<font color=red>注：</font>

* <font color=red size=3>**箭头函数不会创建自己的this**</font>
>箭头函数不会创建自己的this，所以它没有自己的this，它只会从自己的作用域链的上一层继承this。

* <font color=red size=3>**箭头函数继承而来的this指向永远不变**</font>
>箭头函数的this是静态的，`this始终指向函数声明时所在作用域下的this的值`。

例：
```javascript
function getName1 () {console.log(this.name);}
let getName2 = () => {console.log(this.name);}

window.name = '猪八戒';
const school = {name: '孙悟空'};

// 直接调用
getName1(); // 输出为猪八戒，this指向window，调用执行为window。
getName2(); // 输出为猪八戒，this指向window，调用执行为window。

// 通过.call()方法改变this指向
getname1.call(school); // 输出为孙悟空，this指向对象school。
getName2.call(school); // 输出为猪八戒，由于箭头函数下this为静态的，所以此处的this指向window。
```

* .call()/.apply()/.bind()无法改变箭头函数中this的指向
>由于箭头函数的this定义时就已经确定且永远不会改变，所以使用这些方法永远也改变不了箭头函数this的指向。

* 箭头函数不能作为构造函数使用
>因为箭头函数没有自己的this，且this指向永远不会随在哪里调用、被谁调用而改变，所以箭头函数不能作为构造函数使用，或者说构造函数不能定义成箭头函数，否则用new调用时会报错。
```javascript
let Person = (name,age) => {
	this.name = name;
	this.age = age;
}
let zhangsan = new Person('张三',20);  // TypeError: Person is not a constructor（类型错误：对象Person不是一个构造函数）
```

* 箭头函数没有自己的arguments
>箭头函数没有自己的arguments对象。在箭头函数中访问arguments实际上获得的是外层局部（函数）执行环境中的值。
```javascript
let fn = (...values) => {
	console.log(arguments); // 错误，找不到名称“arguments”
}
fn(1,2,3) 
```
* 箭头函数没有原型prototype
* 箭头函数不能用作Generator函数，不能使用yeild关键字
