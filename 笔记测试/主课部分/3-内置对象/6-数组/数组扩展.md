# 数组扩展
## 一：Array.from()
&emsp;&emsp;此方法可以将<font color=skyblue>类数组对象</font>和<font color=skyblue>可以遍历的对象（包括Map数据结构和Set数据结构）</font><font size=3 color=red>转换为真正的数组</font>。

```javascript
let arrayLike = {
    '0': 'a',
    '1': 'b',
    '2': 'c',
    length: 3
};

// ES5的写法
var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']

// ES6的写法
let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']
```

常用于类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的arguments对象。
```javascript
// NodeList集合
let ps = document.querySelectorAll('p');
Array.from(ps).filter(p => {
  return p.textContent.length > 100;
});

// 函数内arguments对象
function fn(){
    let arr = [];
    arr = [].slice.call(arguments); // ES5
    arr = Array.from(arguments); // ES6
    console.log(arr); // [ 1, 2, 3, 4 ]
}
fn(1, 2, 3, 4);
```

如果参数是一个真正的数组，Array.from会返回一个一模一样的新数组。
```javascript
Array.from([1, 2, 3])
// [1, 2, 3]
```

值得提醒的是，扩展运算符（...）也可以将某些数据结构转为数组。
```javascript
// arguments对象
function foo() {
  const args = [...arguments];
}

// NodeList对象
[...document.querySelectorAll('div')]
```

Array.from<font color=skyblue>还可以接受第二个参数</font>，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。
```javascript
Array.from([1, 2, 3], (x) => x * x)
// [1, 4, 9]
```

---
## 二：Array.of()
此方法可以将一组值，转换为数组。
```javascript
let arr = Array.of(3, 11, 8);
console.log(arr); // [3, 11, 8]
```

这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。
```javascript
// 参数为一个时为指定数组的长度
Array(3); // [, , ,]
// 参数为两个及以上时会返回由参数组成的数组
Array(3, 4); // [3, 4]
```

Array.of()基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。
```javascript
Array.of(); // []
Array.of(3); // [3]
Array.of(1, 2); // [1, 2]
```

这种方式在ES5中也可以这样显示
```javascript
function ArrayOf() {
  return [].slice.call(arguments);
}
```

---
## 三：实例方法 copyWithin()
此方法会将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。使用这个方法会改变当前的数组。

此方法接受三个参数：
>1. target（必需）：从该位置<b style="color:red">开始替换数据</b>。如果为负值，表示倒数。

>2. start（可选）：从该位置<b style="color:red">开始读取数据</b>，默认为 0。如果为负值，表示从末尾开始计算。

>3. end（可选）：<b style="color:red">到该位置前停止读取数据</b>，默认等于数组长度。如果为负值，表示从末尾开始计算。
```javascript
// 方法
Array.prototype.copyWithin(target, start = 0, end = this.length)

// 实现
console.log([1, 2, 3, 6, 7, 8].copyWithin(0, 3, 4));
// [6, 2, 3, 6, 7, 8]
/*
[1, 2, 3, 6, 7, 8]
 ^被替换  ^读取
 |________|
*/
```

---
## 四：实例方法 find() 和 findIndex() 
### 1.find()
数组实例的find方法，用于找出<font color=red size=3>**第一个**符合条件的数组成员</font>。

参数是一个回调函数，方法会为此回调函数传递参数。

方法会为回调函数传递三个参数：
>1. 当前的值；
>2. 当前的位置（当前遍历数组位置的索引号）；
>3. 原数组。

如果没有符合条件的成员，则返回undefined。
```javascript
console.log([1, -4, -5, 10].find((n) => n < 0));
// -4

console.log([1, 2].find((a, b, c) => {
    console.log(`${b}：${a}。[${c}]、length：${c.length}`);
}));
// 0：1。[1,2]、length：2
// 1：2。[1,2]、length：2
```

### 2.findIndex()
数组实例的 findIndex 方法的用法与 find 方法非常类似。

返回第一个符合条件的数组成员的位置。

如果所有成员都不符合条件，则返回-1。
```javascript
console.log([1, 2].findIndex((value, index, arr) => {
  return value > 3;
}));
// -1
```
这两种方法都可以接受第二个参数，用来绑定回调函数的this对象。
```javascript
function fn(a) {
  return a > 3;
}
let person = {
  name: "孙悟空",
  age: 18
};
console.log([1, 2, 3].find(fn, person));
// 3，而且this指向为对象person
```

## 五：实例方法 entries()，keys() 和 values()
ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。可以用for...of循环进行遍历。
### 1.entries()
此为对<font color=red>键值对</font>的遍历
```javascript
for (let [index, elem] of ['a', 'b'].entries()) {
  console.log(index, elem);
}
// 0 "a"
// 1 "b"
```

### 2.values()
此为对<font color=red>键值</font>的遍历
```javascript
for (let elem of ['a', 'b'].values()) {
  console.log(elem);
}
// 'a'
// 'b'
```

### 3.keys()
此为对<font color=red>键名</font>的遍历
```javascript
for (let index of ['a', 'b'].keys()) {
  console.log(index);
}
// 0
// 1
```

### 另外
如果不使用for...of循环，可以手动调用遍历器对象的next方法，进行遍历。
```javascript
let letter = ['a', 'b', 'c'];
let entries = letter.entries();
console.log(entries.next().value); // [0, 'a']
console.log(entries.next().value); // [1, 'b']
console.log(entries.next().value); // [2, 'c']
```

---
## 六：实例方法 includes() 
此方法可以表示某个数组<font color=red>是否包含给定的值</font>，与字符串的includes方法类似。

使用此方法会返回一个布尔值。

此方法可以传递两个参数：
>1. 给定的值；
>2. 搜索的起始位置，默认为0，负数表倒数。
```javascript
[1, 2, 3].includes(2); // true
[1, 2, 3].includes(5); // false
[1, 2, NaN].includes(NaN); // true
[1, 2, 3].includes(1, 1); // false
```

此方法可以解决使用 indexOf() 数组方法遍历数组的不足。
```javascript
// 需要额外的比较
function arOf(i) {
  if (i.indexOf(ele) !== -1) {
    return true;
  };
}

// 对NaN的误判
[NaN].indexOf(NaN) // -1
```